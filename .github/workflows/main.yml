name: Auto-Build CoreDNS with Fanout

on:
  schedule:
    - cron: 0 0 * * *  # runs daily at midnight
  workflow_dispatch:  # Manual execution allowed

# Prevent concurrent builds from racing on version.json
concurrency:
  group: build
  cancel-in-progress: false

jobs:
  # ---------------------------------------------------------------------------
  # Job 1: Determine whether a build is needed and compute the new version.
  #
  # Versioning rules (SemVer v2.MINOR.PATCH):
  #   - CoreDNS or Fanout MINOR version change  ->  bump our MINOR, reset PATCH
  #   - CoreDNS/Fanout PATCH, Go build image, or runtime base image change  ->  bump our PATCH
  #   - Source of truth for dependency versions: build-versions.json
  #   - Nothing changed  ->  skip (unless workflow_dispatch)
  # ---------------------------------------------------------------------------
  determine-version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      build_needed: ${{ steps.version.outputs.build_needed }}
      new_version: ${{ steps.version.outputs.new_version }}
      coredns_tag: ${{ steps.deps.outputs.coredns_tag }}
      fanout_tag: ${{ steps.deps.outputs.fanout_tag }}
      go_image: ${{ steps.deps.outputs.go_image }}
      go_toolchain: ${{ steps.deps.outputs.go_toolchain }}
      runtime_base: ${{ steps.deps.outputs.runtime_base }}
    permissions:
      contents: read
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - name: Checkout Repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Load pinned dependency versions
        id: deps
        run: |
          FILE="build-versions.json"
          test -f "${FILE}"

          COREDNS_TAG=$(jq -r '.coredns_tag // ""' "${FILE}")
          FANOUT_TAG=$(jq -r '.fanout_tag // ""' "${FILE}")
          GO_IMAGE=$(jq -r '.go_image // ""' "${FILE}")
          GO_TOOLCHAIN=$(jq -r '.go_toolchain // ""' "${FILE}")
          RUNTIME_BASE=$(jq -r '.runtime_base // ""' "${FILE}")

          if [ -z "${COREDNS_TAG}" ] || [ -z "${FANOUT_TAG}" ] || [ -z "${GO_IMAGE}" ] || [ -z "${GO_TOOLCHAIN}" ] || [ -z "${RUNTIME_BASE}" ]; then
            echo "${FILE} is missing required values." >&2
            exit 1
          fi

          echo "coredns_tag=${COREDNS_TAG}" >> $GITHUB_OUTPUT
          echo "fanout_tag=${FANOUT_TAG}" >> $GITHUB_OUTPUT
          echo "go_image=${GO_IMAGE}" >> $GITHUB_OUTPUT
          echo "go_toolchain=${GO_TOOLCHAIN}" >> $GITHUB_OUTPUT
          echo "runtime_base=${RUNTIME_BASE}" >> $GITHUB_OUTPUT

          echo "Pinned CoreDNS tag: ${COREDNS_TAG}"
          echo "Pinned Fanout tag: ${FANOUT_TAG}"
          echo "Pinned Go build image: ${GO_IMAGE}"
          echo "Pinned Go toolchain: ${GO_TOOLCHAIN}"
          echo "Pinned runtime base image: ${RUNTIME_BASE}"

      - name: Verify pinned Go toolchain
        run: |
          ACTUAL_GO_TOOLCHAIN=$(docker run --rm --platform linux/amd64 "${{ steps.deps.outputs.go_image }}" go version | awk '{print $3, $4}')
          EXPECTED_GO_TOOLCHAIN="${{ steps.deps.outputs.go_toolchain }}"

          echo "Expected Go toolchain: ${EXPECTED_GO_TOOLCHAIN}"
          echo "Actual Go toolchain:   ${ACTUAL_GO_TOOLCHAIN}"

          if [ "${ACTUAL_GO_TOOLCHAIN}" != "${EXPECTED_GO_TOOLCHAIN}" ]; then
            echo "Pinned go_toolchain in build-versions.json does not match go_image." >&2
            exit 1
          fi

      - name: Determine version bump
        id: version
        run: |
          NEW_COREDNS="${{ steps.deps.outputs.coredns_tag }}"
          NEW_FANOUT="${{ steps.deps.outputs.fanout_tag }}"
          NEW_GO_IMAGE="${{ steps.deps.outputs.go_image }}"
          NEW_RUNTIME_BASE="${{ steps.deps.outputs.runtime_base }}"

          STORED_COREDNS=$(jq -r '.coredns // ""' version.json)
          STORED_FANOUT=$(jq  -r '.fanout  // ""' version.json)
          STORED_GO_IMAGE=$(jq -r '.go      // ""' version.json)
          STORED_RUNTIME_BASE=$(jq -r '.alpine  // ""' version.json)
          STORED_VERSION=$(jq -r '.version // "2.0.0"' version.json)

          echo "Stored: coredns=${STORED_COREDNS} fanout=${STORED_FANOUT} go_image=${STORED_GO_IMAGE} runtime_base=${STORED_RUNTIME_BASE} version=${STORED_VERSION}"
          echo "Latest: coredns=${NEW_COREDNS} fanout=${NEW_FANOUT} go_image=${NEW_GO_IMAGE} runtime_base=${NEW_RUNTIME_BASE}"

          # --- nothing changed? ---
          if [ "${NEW_COREDNS}" = "${STORED_COREDNS}" ] && \
             [ "${NEW_FANOUT}"  = "${STORED_FANOUT}"  ] && \
             [ "${NEW_GO_IMAGE}" = "${STORED_GO_IMAGE}" ] && \
             [ "${NEW_RUNTIME_BASE}" = "${STORED_RUNTIME_BASE}" ]; then
            if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
              echo "No dependency changes, but manual trigger – rebuilding ${STORED_VERSION}."
              echo "build_needed=true"             >> $GITHUB_OUTPUT
              echo "new_version=${STORED_VERSION}"  >> $GITHUB_OUTPUT
            else
              echo "No changes detected. Skipping build."
              echo "build_needed=false"            >> $GITHUB_OUTPUT
              echo "new_version=${STORED_VERSION}"  >> $GITHUB_OUTPUT
            fi
            exit 0
          fi

          # --- initial build (stored deps empty) -> use 2.0.0 as-is ---
          if [ -z "${STORED_COREDNS}" ] || [ -z "${STORED_FANOUT}" ]; then
            echo "Initial build – using version 2.0.0"
            echo "build_needed=true"  >> $GITHUB_OUTPUT
            echo "new_version=2.0.0"  >> $GITHUB_OUTPUT
            exit 0
          fi

          # --- compute version bump ---
          MAJOR=$(echo "${STORED_VERSION}" | cut -d. -f1)
          MINOR=$(echo "${STORED_VERSION}" | cut -d. -f2)
          PATCH=$(echo "${STORED_VERSION}" | cut -d. -f3)

          # Extract minor components of CoreDNS / Fanout (e.g. v1.14.1 -> 14)
          OLD_CD_MINOR=$(echo "${STORED_COREDNS}" | sed 's/^v//' | cut -d. -f2)
          NEW_CD_MINOR=$(echo "${NEW_COREDNS}"    | sed 's/^v//' | cut -d. -f2)
          OLD_FO_MINOR=$(echo "${STORED_FANOUT}"  | sed 's/^v//' | cut -d. -f2)
          NEW_FO_MINOR=$(echo "${NEW_FANOUT}"     | sed 's/^v//' | cut -d. -f2)

          if [ "${OLD_CD_MINOR}" != "${NEW_CD_MINOR}" ] || \
             [ "${OLD_FO_MINOR}" != "${NEW_FO_MINOR}" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
            echo "Minor bump (CoreDNS or Fanout minor version changed)"
          else
            PATCH=$((PATCH + 1))
            echo "Patch bump (patch / Go image / runtime base image change)"
          fi

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "New version: v${NEW_VERSION}"
          echo "build_needed=true"           >> $GITHUB_OUTPUT
          echo "new_version=${NEW_VERSION}"  >> $GITHUB_OUTPUT

  # ---------------------------------------------------------------------------
  # Job 2: Preflight build/tests once and produce binaries for all architectures.
  # ---------------------------------------------------------------------------
  preflight:
    name: Preflight (pull/test/build binaries once)
    needs: determine-version
    if: needs.determine-version.outputs.build_needed == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      # security-events: write
    env:
      COREDNS_TAG: ${{ needs.determine-version.outputs.coredns_tag }}
      FANOUT_TAG: ${{ needs.determine-version.outputs.fanout_tag }}
      GO_IMAGE: ${{ needs.determine-version.outputs.go_image }}

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - name: Checkout Repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Get CoreDNS & Plugin
        run: |
          git clone --branch ${{ env.COREDNS_TAG }} --depth 1 https://github.com/coredns/coredns.git
          cd coredns
          echo "fanout:github.com/networkservicemesh/fanout" >> plugin.cfg

      - name: Pull pinned Go image once
        run: docker pull ${{ env.GO_IMAGE }}

      - name: Test once + build all target binaries
        run: |
          mkdir -p artifacts

          docker run --rm \
            -v "${{ github.workspace }}:/work" \
            -w /work/coredns \
            -e FANOUT_TAG=${{ env.FANOUT_TAG }} \
            ${{ env.GO_IMAGE }} \
            sh -ec '
              apt-get -qq update
              apt-get -qq install --no-install-recommends make git gcc libc6-dev ca-certificates
              rm -rf /var/lib/apt/lists/*

              go mod edit -require github.com/networkservicemesh/fanout@${FANOUT_TAG}
              go mod tidy

              make gen
              # Skip upstream integration tests that are known to be flaky in CI containers.
              go test $(go list ./... | grep -v "^github.com/coredns/coredns/test$")

              # Allow git operations inside the container to access the mounted repo
              git config --global --add safe.directory /work/coredns

              mkdir -p /work/artifacts

              export GOOS=linux
              export GOARCH=amd64
              unset GOARM
              echo "Building for GOOS=${GOOS}, GOARCH=${GOARCH}, GOARM=n/a"
              make coredns
              cp coredns /work/artifacts/coredns-amd64

              export GOOS=linux
              export GOARCH=arm64
              unset GOARM
              echo "Building for GOOS=${GOOS}, GOARCH=${GOARCH}, GOARM=n/a"
              make coredns
              cp coredns /work/artifacts/coredns-arm64

              export GOOS=linux
              export GOARCH=arm
              export GOARM=7
              echo "Building for GOOS=${GOOS}, GOARCH=${GOARCH}, GOARM=${GOARM}"
              make coredns
              cp coredns /work/artifacts/coredns-armhf
            '

          cp coredns/Dockerfile artifacts/Dockerfile

      - name: Upload CoreDNS build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: coredns-build-artifacts
          path: artifacts/
          if-no-files-found: error
          retention-days: 1

  # ---------------------------------------------------------------------------
  # Job 3: Build and push per-arch Docker image from prebuilt artifacts.
  # ---------------------------------------------------------------------------
  build:
    name: Build (${{ matrix.arch }})
    needs: [determine-version, preflight]
    if: needs.determine-version.outputs.build_needed == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      matrix:
        include:
          - arch: amd64
            platform: linux/amd64
            goarch: amd64
            goarm: ""
          - arch: arm64
            platform: linux/arm64
            goarch: arm64
            goarm: ""
          - arch: armhf
            platform: linux/arm/v7
            goarch: arm
            goarm: "7"
    env:
      VERSION: ${{ needs.determine-version.outputs.new_version }}
      RUNTIME_BASE: ${{ needs.determine-version.outputs.runtime_base }}

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - name: Download CoreDNS build artifacts
        uses: actions/download-artifact@v4
        with:
          name: coredns-build-artifacts
          path: artifacts

      - name: Prepare build context
        run: |
          mkdir -p build-context
          cp artifacts/Dockerfile build-context/Dockerfile
          cp artifacts/coredns-${{ matrix.arch }} build-context/coredns
          file build-context/coredns

          case "${{ matrix.arch }}" in
            amd64)
              file build-context/coredns | grep -q 'x86-64'
              ;;
            arm64)
              file build-context/coredns | grep -Eq 'aarch64|ARM aarch64'
              ;;
            armhf)
              file build-context/coredns | grep -Eq 'ARM|EABI5'
              ;;
            *)
              echo "Unknown matrix arch: ${{ matrix.arch }}" >&2
              exit 1
              ;;
          esac

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

      - name: Log in to Docker Hub
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@10e90e3645eae34f1e60eeb005ba3a3d33f178e8 # v6.19.2
        with:
          context: build-context/
          file: build-context/Dockerfile
          push: true
          provenance: false
          sbom: false
          platforms: ${{ matrix.platform }}
          build-args: |
            BASE=${{ env.RUNTIME_BASE }}
          tags: |
            tomtonic/coredns-fanout:v${{ env.VERSION }}-${{ matrix.arch }}
          cache-from: type=gha,scope=${{ matrix.arch }}
          cache-to: type=gha,scope=${{ matrix.arch }},mode=max

  # ---------------------------------------------------------------------------
  # Job 4: Create multi-arch manifests and push floating tags.
  # Tags pushed: v2.MINOR.PATCH, v2.MINOR, v2, latest
  # ---------------------------------------------------------------------------
  manifest:
    name: Create Multi-Arch Manifests
    needs: [build, determine-version]
    runs-on: ubuntu-latest
    env:
      VERSION: ${{ needs.determine-version.outputs.new_version }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - name: Log in to Docker Hub
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

      - name: Compute floating tags
        id: tags
        run: |
          MINOR_TAG="v$(echo "${{ env.VERSION }}" | cut -d. -f1-2)"
          echo "minor_tag=${MINOR_TAG}" >> $GITHUB_OUTPUT
          echo "Floating tags: v${{ env.VERSION }}, ${MINOR_TAG}, v2, latest"

      - name: Create and push multi-arch tags
        run: |
          SOURCE_AMD64="tomtonic/coredns-fanout:v${{ env.VERSION }}-amd64"
          SOURCE_ARM64="tomtonic/coredns-fanout:v${{ env.VERSION }}-arm64"
          SOURCE_ARMHF="tomtonic/coredns-fanout:v${{ env.VERSION }}-armhf"

          docker buildx imagetools create \
            --tag tomtonic/coredns-fanout:v${{ env.VERSION }} \
            "${SOURCE_AMD64}" "${SOURCE_ARM64}" "${SOURCE_ARMHF}"
          docker buildx imagetools inspect tomtonic/coredns-fanout:v${{ env.VERSION }}

          docker buildx imagetools create \
            --tag tomtonic/coredns-fanout:${{ steps.tags.outputs.minor_tag }} \
            "${SOURCE_AMD64}" "${SOURCE_ARM64}" "${SOURCE_ARMHF}"
          docker buildx imagetools inspect tomtonic/coredns-fanout:${{ steps.tags.outputs.minor_tag }}

          docker buildx imagetools create \
            --tag tomtonic/coredns-fanout:v2 \
            "${SOURCE_AMD64}" "${SOURCE_ARM64}" "${SOURCE_ARMHF}"
          docker buildx imagetools inspect tomtonic/coredns-fanout:v2

          docker buildx imagetools create \
            --tag tomtonic/coredns-fanout:latest \
            tomtonic/coredns-fanout:v${{ env.VERSION }}-amd64 \
            tomtonic/coredns-fanout:v${{ env.VERSION }}-arm64 \
            tomtonic/coredns-fanout:v${{ env.VERSION }}-armhf
          docker buildx imagetools inspect tomtonic/coredns-fanout:latest

  # ---------------------------------------------------------------------------
  # Job 5: Commit version.json and README *after* a successful build & push.
  # This ensures the stored state only advances when images actually exist.
  # ---------------------------------------------------------------------------
  finalize:
    name: Update Version Tracking
    needs: [manifest, determine-version]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      VERSION: ${{ needs.determine-version.outputs.new_version }}
      COREDNS_TAG: ${{ needs.determine-version.outputs.coredns_tag }}
      FANOUT_TAG: ${{ needs.determine-version.outputs.fanout_tag }}
      GO_IMAGE: ${{ needs.determine-version.outputs.go_image }}
      GO_TOOLCHAIN: ${{ needs.determine-version.outputs.go_toolchain }}
      RUNTIME_BASE: ${{ needs.determine-version.outputs.runtime_base }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@a90bcbc6539c36a85cdfeb73f7e2f433735f215b # v2.15.0
        with:
          egress-policy: audit

      - name: Checkout Repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: Update version.json
        run: |
          jq \
            --arg v "${{ env.VERSION }}" \
            --arg c "${{ env.COREDNS_TAG }}" \
            --arg f "${{ env.FANOUT_TAG }}" \
            --arg g "${{ env.GO_IMAGE }}" \
            --arg a "${{ env.RUNTIME_BASE }}" \
            '.version=$v | .coredns=$c | .fanout=$f | .go=$g | .alpine=$a' \
            version.json > version.json.tmp
          mv version.json.tmp version.json

      - name: Update README.md
        run: |
          DATE_UTC=$(date -u +"%d.%m.%Y %H:%M UTC")
          sed -i "s/coredns-fanout version: .*/coredns-fanout version: v${{ env.VERSION }}/" README.md
          sed -i "s/Latest release lookup: .*/Latest release lookup: ${DATE_UTC}/" README.md
          sed -i "s/Latest CoreDNS release: .*/Latest CoreDNS release: ${{ env.COREDNS_TAG }}/" README.md
          sed -i "s/Latest Fanout release: .*/Latest Fanout release: ${{ env.FANOUT_TAG }}/" README.md
          sed -i "s|Go toolchain: .*|Go toolchain: ${{ env.GO_TOOLCHAIN }} (${{ env.GO_IMAGE }})|" README.md
          sed -i "s|Runtime base image: .*|Runtime base image: ${{ env.RUNTIME_BASE }}|" README.md

      - name: Commit and push
        run: |
          git config --global user.name "GitHub Action Auto-Build"
          git config --global user.email "action@github.com"
          git add version.json README.md
          git commit -m "Release v${{ env.VERSION }} [auto]" || echo "No changes to commit"
          git push origin main
